<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vala | 대체로 무해함</title>
    <link>/tags/vala/</link>
      <atom:link href="/tags/vala/index.xml" rel="self" type="application/rss+xml" />
    <description>Vala</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ko-kr</language><copyright>© lethean</copyright><lastBuildDate>Wed, 15 Jun 2011 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Vala</title>
      <link>/tags/vala/</link>
    </image>
    
    <item>
      <title>Vala 언어 소개</title>
      <link>/2011/06/15/2011-06-15-vala-language-introduction/</link>
      <pubDate>Wed, 15 Jun 2011 00:00:00 +0000</pubDate>
      <guid>/2011/06/15/2011-06-15-vala-language-introduction/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://live.gnome.org/Vala&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vala&lt;/a&gt;
 언어는 C# 언어와 문법이 비슷한 객체 지향 언어입니다. Vala 언어로 작성한 소스를 이용해 실행 파일을 직접 만들 수도 있지만 C 소스 코드로 변환할 수도 있는데, 더 정확히 말하면, GObject 프레임워크를 이용하는 순수 GLib 기반 C 언어 코드를 생성한 뒤 이를 다시 C 컴파일를 이용해 실행 파일을 생성합니다. 따라서 이렇게 생성된 C 소스 코드는 이론적으로 GLib 라이브러리가 포팅된 어떤 플랫폼에서든 동작할 수 있고, 실행 속도 역시 C 언어로 작성된 코드와 거의 동일한 성능을 보여 줍니다. 생성된 소스 코드나 라이브러리는 GLib 외의 다른 라이브러리 의존성이 없기 때문에(posix 프로파일을 사용하면 GLib 의존성도 없어짐) 당연히 다른 C 언어에서도 이용할 수 있고, 반대로 C 언어로 개발된 라이브러리를 별다른 바인딩 코드 없이 VAPI 기법을 통해 사용할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;요즘 GNOME 프로젝트 개발 흐름을 보면 크게 두 가지 언어, JavaScript와 Vala가 대두되고 있는데, GUI 같은 상위 제어 모듈은 JavaScript로 구현하고, 성능이 중요한 하위 모듈은 C + Vala로 구현한 뒤 이를 하나의 프로그램에서 합쳐서 성능과 개발 효율을 동시에 얻고자 하는 것 같습니다.&lt;/p&gt;
&lt;p&gt;사실, GObject 프레임워크가 좋긴 하지만, 여러 고수준 언어에서 사용할 때와는 달리 C 언어에서 사용하려면 어려움이 많아서 비판을 많이 받습니다. Vala 언어는, 말하자면, 이러한 반복되는 코드 재작성(boilerplate code)과 자잘한 코딩을 획기적으로 줄여주면서 C 언어로 GObject 객체 지향 프로그램을 할 수 있도록 도와주는 역할을 하는 겁니다. C++의 복잡함은 싫고, 인터프리터 언어의 느림은 견디기 힘들고&amp;hellip; 결국 목마른 사람들이 직접 우물을 판 셈입니다.&lt;/p&gt;
&lt;p&gt;그렇다고 Vala 언어는 비단 GTK+ / Clutter 기반 GUI 프로그램을 개발하는데만 사용되지 않고, 서버 데몬[
&lt;a href=&#34;http://www.freedesktop.org/wiki/Software/systemd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;systemd&lt;/a&gt;
] 같은 콘솔 프로그램 개발에도 사용합니다. 이미 
&lt;a href=&#34;http://live.gnome.org/Vala/Documentation#Projects_Developed_in_Vala&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;수많은 프로그램이 Vala를 이용해 개발&lt;/a&gt;
되었는데, C 언어로 개발되었던 기존 프로그램을 Vala 언어로 다시 작성한 것[
&lt;a href=&#34;http://live.gnome.org/Cheese&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cheese&lt;/a&gt;
]도 눈에 띕니다.&lt;/p&gt;
&lt;p&gt;그러나, Vala 언어의 단점이라면, C 언어 부류인 C#과 문법이 비슷하긴 하지만, 무엇보다도 새 언어를 익혀야 한다는 점, 그리고 GLib / GObject 개념에 익숙하지 않을 경우 익히는데 조금 더 시간과 노력이 필요하다는 점입니다. 물론, 오픈 소스 리눅스 개발자 커뮤니티에서 개발되어, 아직은, 그 안에서만 사용하는 마이너 언어라는 한계 때문에, 즉 상용 벤더의 지원이나 Visual Studio, XCode 등과 같은 완벽한 통합 개발 환경도 없기 때문에, 많은 개발자를 끌어당길 매력이 부족한 것도 사실입니다. 하지만 한편으로는, 오픈 소스이기 때문에 오히려 미래가 더 투명한게 아닐까 하는 생각도 듭니다.&lt;/p&gt;
&lt;p&gt;아무튼, Vala 언어에 대해 더 관심이 생기는 분은 
&lt;a href=&#34;http://live.gnome.org/Vala/Documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;소개, FAQ, 튜토리얼 문서&lt;/a&gt;
 등을 한 번 훑어보시길 바랍니다. 샘플 코드도 많고, 튜토리얼도 참 많습니다. 아마 C++ / C# / Java / Python 등과 같은 객체 지향 언어에 익숙한 개발자라면 생각보다 어렵지 않다는 사실을 알게 될 겁니다. 더불어, Vala 컴파일러가 생성한 C 소스 코드를 한 번 확인해 보시면, 객체 지향 개념을 이런 식으로 코딩하고 구현할 수도 있구나 하는, 결국 중요한 건 개발자의 능력이지, 사용하는 언어나 개발도구가 전부가 아니란 것도 느끼게 됩니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
